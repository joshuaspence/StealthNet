/* @formatter:off */
/******************************************************************************
 * ELEC5616
 * Computer and Network Security, The University of Sydney
 * Copyright (C) 2002-2004, Matt Barrie, Stephen Gould and Ryan Junee
 *
 * PACKAGE:         StealthNet
 * FILENAME:        DecryptedPacket.java
 * AUTHORS:         Matt Barrie, Stephen Gould, Ryan Junee and Joshua Spence
 * DESCRIPTION:     Implementation of a StealthNet packet. This class represents
 * 					decrypted packet contents. This class is more closely based
 * 					on the original 'Packet' class than the EncryptedPacket
 * 					class.
 *
 *****************************************************************************/
/* @formatter:on */

package StealthNet;

/* Import Libraries ******************************************************** */

import java.io.UnsupportedEncodingException;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.management.InvalidAttributeValueException;

import StealthNet.Security.Encryption;
import StealthNet.Security.MessageAuthenticationCode;
import StealthNet.Security.NonceGenerator;

/* StealthNet.DecryptedPacket Class Definition ***************************** */

/**
 * A class to store the decrypted data passed between StealthNet clients. A
 * StealthNet "packet" consists of three parts: <ul> <li>command</li>
 * <li>data</li> <li>nonce</li> </ul>
 * 
 * A message nonce is generated by a pseudo-random random generator. The message
 * nonce is used to prevent replay attacks, because once the packet is read at
 * the receiving end of the communications, the nonce is "consumed" and cannot
 * be used again for future communications. The Packet class <em>will</em> allow
 * packets to be created without a nonce (if a null <pre>NonceGenerator</pre>
 * instance is passed to the function). A higher layer should check whether or
 * not this should be allowed.
 * 
 * @author Matt Barrie
 * @author Stephen Gould
 * @author Ryan Junee
 * @author Joshua Spence
 */
public class DecryptedPacket {
	/** Commands. */
	public static final byte CMD_NULL = 0x00; 				// used for acknowledgement
	public static final byte CMD_LOGIN = 0x01;
	public static final byte CMD_LOGOUT = 0x02;
	public static final byte CMD_MSG = 0x03;
	public static final byte CMD_CHAT = 0x04;
	public static final byte CMD_FTP = 0x05;
	public static final byte CMD_LIST = 0x06;
	public static final byte CMD_CREATESECRET = 0x07;
	public static final byte CMD_SECRETLIST = 0x08;
	public static final byte CMD_GETSECRET = 0x09;
	
	public static final byte CMD_GETPUBLICKEY = 0x0A;
	/** request the public key of a user */
	
	/**
	 * Security-specific commands - these should never be returned to a client
	 * or server, but rather should always be handled within the Comms class.
	 */
	public static final byte CMD_AUTHENTICATIONKEY = 0x7A;	// common key for Diffie-Hellman key exchange
	public static final byte CMD_INTEGRITYKEY = 0x7B;			// key for MAC generator
	public static final byte CMD_NONCESEED = 0x7C;			// seed for nonce generator
	public static final byte CMD_PUBLICKEY = 0x7D;			// asymmetric public key
	
	/** Packet contents. */
	byte command;							// The command being sent in the packet.
	final byte[] data;						// The data being sent in the packet.
	final byte[] nonce;					// The pseudo-random nonce for this packet.
	final MessageAuthenticationCode mac;	// The MAC used to provide a message
											// digest.
	
	/** Null constructor with no digest and no nonce. */
	public DecryptedPacket() {
		command = DecryptedPacket.CMD_NULL;
		data = new byte[0];
		
		/** No nonce is available. */
		nonce = new byte[0];
		
		/** No MAC is available. */
		mac = null;
	}
	
	/**
	 * Constructor with no digest. Explicitly copies the data array contents.
	 * 
	 * @param cmd The command to be sent in the packet.
	 * @param d The data to be sent in the packet.
	 */
	public DecryptedPacket(final byte cmd, final byte[] d) {
		command = cmd;
		
		if (d == null)
			data = new byte[0];
		else {
			data = new byte[d.length];
			System.arraycopy(d, 0, data, 0, d.length);
		}
		
		/** No nonce is available. */
		nonce = new byte[0];
		
		/** No MAC is available. */
		mac = null;
	}
	
	/**
	 * Constructor with digest and nonce. Explicitly copies the data array
	 * contents.
	 * 
	 * @param cmd The command to be sent in the packet.
	 * @param dLen The length of the data array.
	 * @param d The data to be sent in the packet.
	 * @param mac The MessageAuthenticationCode instance to provide a MAC
	 *        digest.
	 * @param nonceGenerator The NonceGenerator instance to provide a nonce.
	 */
	public DecryptedPacket(final byte cmd, final byte[] d, final int dLen, final MessageAuthenticationCode mac, final NonceGenerator nonceGenerator) {
		command = cmd;
		
		/** Copy the data. */
		if (d == null)
			data = new byte[0];
		else {
			data = new byte[dLen];
			System.arraycopy(d, 0, data, 0, dLen);
		}
		
		/** Create the nonce (if possible). */
		if (nonceGenerator != null)
			nonce = nonceGenerator.getNext();
		else
			nonce = new byte[0];
		
		this.mac = mac;
	}
	
	/**
	 * Constructor. This function must "undo" the effects of the
	 * <pre>toString()</pre> function, because this function converts the
	 * received data into a packet at the receiving end of communications.
	 * 
	 * @param str A string consisting of the packet contents.
	 */
	public DecryptedPacket(String str) {
		/**
		 * Add padding if necessary, to make the packet length an integer number
		 * of bytes (each represented by 2 hexadecimal characters).
		 */
		if (str.length() % 2 == 1)
			str = "0" + str;
		
		if (str.length() == 0) {
			/** NULL packet. */
			command = DecryptedPacket.CMD_NULL;
			data = new byte[0];
			nonce = null;
			mac = null;
		} else {
			/** Current index of the string. */
			int current = 0;
			
			/** Command (1 byte). */
			command = (byte) (16 * Utility.singleHexToInt(str.charAt(current++)) + Utility.singleHexToInt(str.charAt(current++)));
			
			/** Data length (4 bytes). */
			final int dataLen = Utility.hexToInt(str.substring(current, current + 4 * Utility.HEX_PER_BYTE));
			current += 4 * Utility.HEX_PER_BYTE;
			
			/** Data (dataLen bytes). */
			data = new byte[dataLen];
			for (int i = 0; i < data.length; i++)
				data[i] = (byte) (16 * Utility.singleHexToInt(str.charAt(current++)) + Utility.singleHexToInt(str.charAt(current++)));
			
			/** Nonce length (4 bytes). */
			final int nonceLen = Utility.hexToInt(str.substring(current, current + 4 * Utility.HEX_PER_BYTE));
			current += 4 * Utility.HEX_PER_BYTE;
			
			/** Nonce (nonceLen bytes). */
			nonce = new byte[nonceLen];
			for (int i = 0; i < nonce.length; i++)
				nonce[i] = (byte) (16 * Utility.singleHexToInt(str.charAt(current++)) + Utility.singleHexToInt(str.charAt(current++)));
			
			/** No MAC is available. */
			mac = null;
		}
	}
	
	/**
	 * Converts the packet to a string. This function must undo the effects of
	 * the <pre>DecryptedPacket(String)</pre> constructor, because this function
	 * is used to convert a packet to a string for transmission at the sending
	 * end of communications.
	 * 
	 * @return A string representing the contents of the packet.
	 */
	@Override
	public String toString() {
		String str = "";
		int lowHalfByte, highHalfByte;
		
		/** Command (1 byte). */
		highHalfByte = command >= 0 ? command : 256 + command;
		lowHalfByte = highHalfByte & 0xF;
		highHalfByte /= Utility.HEXTABLE.length;
		str += Utility.HEXTABLE[highHalfByte];
		str += Utility.HEXTABLE[lowHalfByte];
		
		/** Data length (4 bytes). */
		str += Utility.intToHex(data.length);
		
		/** Data (data.length/2 bytes). */
		for (final byte element : data) {
			highHalfByte = element >= 0 ? element : 256 + element;
			lowHalfByte = highHalfByte & 0xF;
			highHalfByte /= Utility.HEXTABLE.length;
			str += Utility.HEXTABLE[highHalfByte];
			str += Utility.HEXTABLE[lowHalfByte];
		}
		
		/** Nonce length (4 bytes). */
		str += Utility.intToHex(nonce.length);
		
		/** Nonce (nonce.length/2 bytes). */
		for (final byte element : nonce) {
			highHalfByte = element >= 0 ? element : 256 + element;
			lowHalfByte = highHalfByte & 0xF;
			highHalfByte /= Utility.HEXTABLE.length;
			str += Utility.HEXTABLE[highHalfByte];
			str += Utility.HEXTABLE[lowHalfByte];
		}
		
		/** Done. */
		return str;
	}
	
	/**
	 * Get the name of a command from its byte value. For debug purposes only.
	 * 
	 * @param command The byte value of the command to query the name of.
	 * @return A String containing the name of the command.
	 */
	public static String getCommandName(final byte command) {
		switch (command) {
			case CMD_NULL:
				return "CMD_NULL";
			case CMD_LOGIN:
				return "CMD_LOGIN";
			case CMD_LOGOUT:
				return "CMD_LOGOUT";
			case CMD_MSG:
				return "CMD_MSG";
			case CMD_CHAT:
				return "CMD_CHAT";
			case CMD_FTP:
				return "CMD_FTP";
			case CMD_LIST:
				return "CMD_LIST";
			case CMD_CREATESECRET:
				return "CMD_CREATESECRET";
			case CMD_SECRETLIST:
				return "CMD_SECRETLIST";
			case CMD_GETSECRET:
				return "CMD_GETSECRET";
			case CMD_GETPUBLICKEY:
				return "CMD_GETPUBLICKEY";
			case CMD_AUTHENTICATIONKEY:
				return "CMD_AUTHENTICATIONKEY";
			case CMD_INTEGRITYKEY:
				return "CMD_INTEGRITYKEY";
			case CMD_NONCESEED:
				return "CMD_NONCESEED";
			case CMD_PUBLICKEY:
				return "CMD_PUBLICKEY";
			default:
				return "UNKNOWN";
		}
	}
	
	/**
	 * Get a string representation of the packet. For debug purposes only.
	 * 
	 * @return A comma-separated string containing the the value of each of the
	 *         packet's fields. For purely cosmetic purposes, newline characters
	 *         will be replaced by semicolons.
	 */
	public String getDecodedString() {
		String str = "";
		
		/** Packet name. */
		str += getCommandName(command);
		str += ", ";
		
		/** Packet data. */
		if (data.length > 0)
			str += new String(data).replaceAll("\n", ";");
		else
			str += "null";
		str += ", ";
		
		/** Packet nonce. */
		if (nonce != null && nonce.length > 0)
			str += Utility.getHexValue(nonce);
		else
			str += "null";
		
		return str;
	}
	
	/**
	 * Encrypt this packet.
	 * 
	 * @param e The encryption instance to encrypt the packet. If null, then the
	 *        packet will not be encrypted.
	 * @return The encrypted packet.
	 * 
	 * @throws BadPaddingException
	 * @throws IllegalBlockSizeException
	 * @throws UnsupportedEncodingException
	 * @throws IllegalArgumentException
	 * @throws InvalidAttributeValueException
	 */
	public EncryptedPacket encrypt(final Encryption e) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, InvalidAttributeValueException, IllegalArgumentException {
		if (e != null) {
			final byte[] encryptedData = e.encrypt(toString());
			return new EncryptedPacket(encryptedData, encryptedData.length, mac);
		} else
			return new EncryptedPacket(toString().getBytes(), toString().getBytes().length, mac);
	}
}

/******************************************************************************
 * END OF FILE: DecryptedPacket.java
 *****************************************************************************/
